-- turtle short cuts. mainly handles things like fuel, and special digging

local th = 0
local tx = 0
local ty = 0
local tz = 0
local callback = nil
local sel = 1

function cb()
	if callback ~= nil then
		callback(th,tx,ty,tz)
	end
end

function fuel()
	if turtle.getFuelLevel() <= 10 then
		turtle.select(1)
		turtle.refuel(1)
	end
end

-- Location Functions --

function setLoc(h,x,y,z)
	th = h
	tx = x
	ty = y
	tz = z
	cb()
end

function getLoc()
	return th,tx,ty,tz
end

function getLocUp()
	return tx,ty+1,tz
end

function getLocDn()
	return tx,ty-1,tz
end

function getLocFd()
	if th%2 == 0 then
		return tx, ty, tz + (th - 1)
	else
		return tx - (th - 2), ty, tz
	end
end

function getLocBk()
	if th%2 == 0 then
		return tx, ty, tz - (th - 1)
	else
		return tx + (th - 2), ty, tz
	end
end

function getLocRt()
	local h = (th + 1) % 4

	if h%2 == 0 then
		return tx, ty, tz + (h - 1)
	else
		return tx - (h - 2), ty, tz
	end
end

function getLocLt()
	local h = ((th - 1) + 4) % 4

	if h%2 == 0 then
		return tx, ty, tz + (h - 1)
	else
		return tx - (h - 2), ty, tz
	end
end

-- utilities --
function select(i)
	if i ~= sel then
		turtle.select(i)
		sel = i
	end
end

function _compare(fn, i)
	-- save current selection
	local s = sel

	-- change if set
	if i ~= nil then
		select(i)
	end

	-- do check
	local flag = fn()

	-- set selection back
	if s ~= sel and s ~= 0 then
		select(s)
	end

	-- return result
	return flag
end

function compare(i)
	return _compare(turtle.compare, i)
end

function compareUp(i)
	return _compare(turtle.compareUp, i)
end

function compareDown(i)
	return _compare(turtle.compareDown, i)
end

function detect()
	return turtle.detect()
end

function detectUp()
	return turtle.detect()
end

function detectDown()
	return turtle.detect()
end

function place()
	return turtle.place()
end

function placeUp()
	return turtle.placeUp()
end

function placeDown()
	return turtle.placeDown()
end

function attack()
	return turtle.attack()
end

function attackUp()
	return turtle.attackUp()
end

function attackDown()
	return turtle.attackDown()
end


-- basic movement functions --

function up()
	fuel()
	local flag = turtle.up()

	if flag then ty = ty + 1 end
	cb()
	return flag
end

function forward()
	fuel()
	local flag = turtle.forward()

	if flag then
		if th%2 == 0 then
			tz = tz + (th - 1)
		else
			tx = tx - (th - 2)
		end
	end
	cb()
	return flag
end

function back()
	fuel()

	local flag = turtle.back()

	if flag then
		if th%2 == 0 then
			tz = tz - (th - 1)
		else
			tx = tx + (th - 2)
		end
	end
	cb()
	return flag
end

function down()
	fuel()
	local flag = turtle.down()

	if flag then
		ty = ty - 1
	end
	cb()
	return flag
end

function turnRight()
	turtle.turnRight()
	th = (th + 1) % 4
	cb()
end

function turnLeft()
	turtle.turnLeft()
	th = ((th - 1) + 4) % 4
	cb()
end

function turnHeading(t)
	if t == th then
		return
	end

	if th - t == 1 or (t == 3 and th == 0) then
		while th ~= t do
			lt()
		end
	else
		while th ~= t do
			rt()
		end
	end
end

-- movement shortcuts --
function rt()
	return turnRight()
end

function lt()
	return turnLeft()
end

function dn()
	return down()
end

function fd()
	return forward()
end

function bk()
	return back()
end

-- dig wrappers --
function dig()
	return turtle.dig()
end

function digUp()
	return turtle.digUp()
end

function digDown()
	return turtle.digDown()
end

-- dig chests --

function digChest()
	while turtle.suck() do
		os.sleep(0.5)
	end

	return dig()
end


function digChestDown()
	while turtle.suckDown() do
		os.sleep(0.5)
	end

	return digDown()
end

function digChestUp()
	while turtle.suckUp() do
		os.sleep(0.5)
	end

	return digUp()
end

-- dig gravel/sand
function digAllUp()
	while detectUp() do
		digUp()
		os.sleep(0.5)
	end
end

function digAll()
	while detect() do
		dig()
		os.sleep(0.5)
	end
end


function isInventoryFull()
	for i=1,16 do
		if turtle.getItemCount() == 0 then
			return false
		end
	end

	return true
end



-- advanced movement -- 

-- move/attack commands --
function _mvAttack(mvfn, dfn, atckfn)
	while not mvfn() and not dfn() do
		atckfn()
	end
end

function upAttack()
	_mvAttack(up, detectUp, turtle.attackUp)
end

function downAttack()
	_mvAttack(down, detectDown, turtle.attackDown)
end

function forwardAttack()
	_mvAttack(forward, detect, turtle.attack)
end

-- move, dig/attack --
function _mvDigAttack(fnMv, fnDetect, fnDig, fnAttack)
	while not fnMv() do
		-- if block, then dig
		if fnDetect() then
			fnDig()
			os.sleep(0.5)
		else
			-- this is a mob, attack until nothing to attack
			while fnAttack() do end
		end
	end

	return true;
end

function upDigAttack()
	_mvDigAttack(up, detectUp, turtle.digUp, turtle.attackUp)
end

function forwardDigAttack()
	_mvDigAttack(forward, detect, turtle.dig, turtle.attack)
end

function downDigAttack()
	_mvDigAttack(down, detectDown, digDown, turtle.attackDown)
end


-- move/dig --
function _mvDig(fnDetect, fnMove, fnDig)
	while fnDetect() do
		fnDig()
		os.sleep(0.5)
	end

	return fnMove()
end

function forwardDig()
	_mvDig(detect, dig, forward)
end

function upDig()
	_mvDig(detectUp, digUp, up)
end

function downDig()
	_mvDig(detectDown, digDown, down)
end


--replaces the item in the world with the item in slot i
function _replace(fnCompare, fnDetect, fnDig, fnPlace, i)
	select(i)
	if not fnCompare() or not fnDetect() then
		fnDig()
		fnPlace()
	end
end

function replace(i)
	_replace(compare, detect, dig, turtle.place, i)
end	
	
function replaceUp(i)
	_replace(compareUp, detectUp, digUp, turtle.placeUp, i)
end	
	
function replaceDown(i)
	_replace(compareDown, detectDown, digDown, turtle.placeDown, i)
end	

-- coordinate based movement --

function moveToX(x)
	if tx > x then
		turnHeading(3)
	elseif tx < x then
		turnHeading(1)
	end

	while tx ~= x do
		forwardDigAttack()
	end
end

function moveToZ(z)
	if tz > z then
		turnHeading(0)
	elseif tz < z then
		turnHeading(2)
	end

	while tz ~= z do
		forwardDigAttack()
	end
end

function moveToY(y)
	while y > ty do
		upDigAttack()
	end

	while y < ty do
		downDigAttack()
	end
end


function goto(x,y,z)
	if ty < y then
		moveToY(y)
	end

	if math.abs(tx - x) < math.abs(tz - z) then
		moveToX(x)
		moveToZ(z)
	else
		moveToZ(z)
		moveToX(x)
	end

	if ty > y then
		moveToY(y)
	end
end

