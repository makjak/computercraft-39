-- turtle short cuts. mainly handles things like fuel, and special digging

local th = 0
local tx = 0
local ty = 0
local tz = 0
local callback = nil

function cb()
	if callback ~= nil then
		callback(th,tx,ty,tz)
	end
end

function fuel()
	if turtle.getFuelLevel() <= 10 then
		turtle.select(1)
		turtle.refuel(1)
	end
end

function setLoc(h,x,y,z)
	th = h
	tx = x
	ty = y
	tz = z
	cb()
end

function getLoc()
	return th,tx,ty,tz
end

function getLocUp()
	return tx,ty+1,tz
end

function getLocDn()
	return tx,ty-1,tz
end

function getLocFd()
	if th%2 == 0 then
		return tx, ty, tz + (th - 1)
	else
		return tx - (th - 2), ty, tz
	end
end

function getLocBk()
	if th%2 == 0 then
		return tx, ty, tz - (th - 1)
	else
		return tx + (th - 2), ty, tz
	end
end

function getLocRt()
	local h = (th + 1) % 4

	if h%2 == 0 then
		return tx, ty, tz + (h - 1)
	else
		return tx - (h - 2), ty, tz
	end
end

function getLocLt()
	local h = ((th - 1) + 4) % 4

	if h%2 == 0 then
		return tx, ty, tz + (h - 1)
	else
		return tx - (h - 2), ty, tz
	end
end

function up()
	fuel()
	local flag = turtle.up()

	if flag then ty = ty + 1 end
	cb()
	return flag
end

function upAttack()
	while not up() and not turtle.detectUp() do
		turtle.attackUp()
	end
end

function upDigAttack()
	while not up() do
		-- if block, then dig
		if turtle.detectUp() then
			turtle.digUp()
			os.sleep(0.5)
		else
			-- this is a mob, attack until nothing to attack
			while turtle.attackUp() do end
		end
	end

	return true;
end

function forward()
	fuel()
	local flag = turtle.forward()

	if flag then
		if th%2 == 0 then
			tz = tz + (th - 1)
		else
			tx = tx - (th - 2)
		end
	end
	cb()
	return flag
end

function forwardAttack()
	while not forward() and not turtle.detect() do
		turtle.attack()
	end
end

function forwardDig()
	while turtle.detect() do
		turtle.dig()
		os.sleep(0.5)
	end

	return forward()
end

function forwardDigAttack()
	while not forward() do
		-- if block, then dig
		if turtle.detect() then
			turtle.dig()
			os.sleep(0.5)
		else
			-- this is a mob, attack until nothing to attack
			while turtle.attack() do end
		end
	end

	return true;
end

function back()
	fuel()

	local flag = turtle.back()

	if flag then
		if th%2 == 0 then
			tz = tz - (th - 1)
		else
			tx = tx + (th - 2)
		end
	end
	cb()
	return flag
end

function down()
	fuel()
	local flag = turtle.down()

	if flag then
		ty = ty - 1
	end
	cb()
	return flag
end

function downAttack()
	while not down() and not turtle.detectDown() do
		turtle.attackDown()
	end
end

function downDigAttack()
	while not down() do
		if turtle.detectDown() then
			turtle.digDown()
		else
			while turtle.attackDown() do end
		end
	end
end

function turnRight()
	turtle.turnRight()
	th = (th + 1) % 4
	cb()
end

function turnLeft()
	turtle.turnLeft()
	th = ((th - 1) + 4) % 4
	cb()
end

function digChest()
	while turtle.suck() do
		os.sleep(0.5)
	end

	return turtle.dig()
end

function rt()
	return turnRight()
end

function lt()
	return turnLeft()
end

function dn()
	return down()
end

function fd()
	return forward()
end

function bk()
	return back()
end

function digChestDown()
	while turtle.suckDown() do
		os.sleep(0.5)
	end

	return turtle.digDown()
end

function digChestUp()
	while turtle.suckUp() do
		os.sleep(0.5)
	end

	return turtle.digUp()
end

function isInventoryFull()
	for i=1,16 do
		if turtle.getItemCount() == 0 then
			return false
		end
	end

	return true
end

function digAllUp()
	while turtle.detectUp() do
		turtle.digUp()
		os.sleep(0.5)
	end
end

function digAll()
	while turtle.detect() do
		turtle.dig()
		os.sleep(0.5)
	end
end


--replaces the item in the world with the item in slot i
function replace(i)
	turtle.select(i)
	if not turtle.compare() or not turtle.detect() then
		turtle.dig()
		turtle.place()
	end
end	
	
function replaceUp(i)
	turtle.select(i)
	if not turtle.compareUp() or not turtle.detectUp() then
		turtle.digUp()
		turtle.placeUp()
	end
end	
	
function replaceDown(i)
	turtle.select(i)
	if not turtle.compareDown() or not turtle.detectDown() then
		turtle.digDown()
		turtle.placeDown()
	end
end	

function turnHeading(t)
	if t == th then
		return
	end

	if th - t == 1 or (t == 3 and th == 0) then
		while th ~= t do
			lt()
		end
	else
		while th ~= t do
			rt()
		end
	end
end


function moveToX(x)
	if tx > x then
		turnHeading(3)
	elseif tx < x then
		turnHeading(1)
	end

	while tx ~= x do
		forwardDigAttack()
	end
end

function moveToZ(z)
	if tz > z then
		turnHeading(0)
	elseif tz < z then
		turnHeading(2)
	end

	while tz ~= z do
		forwardDigAttack()
	end
end

function moveToY(y)
	while y > ty do
		upDigAttack()
	end

	while y < ty do
		downDigAttack()
	end
end


function goto(x,y,z)
	if ty < y then
		moveToY(y)
	end

	if math.abs(tx - x) < math.abs(tz - z) then
		moveToX(x)
		moveToZ(z)
	else
		moveToZ(z)
		moveToX(x)
	end

	if ty > y then
		moveToY(y)
	end
end

