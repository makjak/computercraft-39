-- Will clean up floating blocks and then return to start
-- slot 1 = fuel
-- slot 2+ = empty

local maxY = 0
local minY = 0
local scannedLocations = {}
local newLocations = {}
local roofLocations = {}
local roofScanned = {}


function hashLoc(x,y,z)
	return x..","..y..","..z
end

function isQueued(x,y,z)
	return newLocations[hashLoc(x,y,z)] ~= nil
end

function isScanned(x,y,z)
	return scannedLocations[hashLoc(x,y,z)] ~= nil
end

function isHandled(x,y,z)
	if isQueued(x,y,z) then
		return true
	end

	return isScanned(x,y,z)
end

function setScanned(x,y,z)
	scannedLocations[hashLoc(x,y,z)] = true
end

function setScannedRoof(x,y,z)
	roofScanned[hashLoc(x,y,z)] = true
end

function addQueueRoof(x,y,z)
	roofLocations[hashLoc(x,y,z)] = {x=x,y=y,z=z}
end

function addQueue(x,y,z)
	if not isHandled(x,y,z) then
		print("adding "..x..","..y..","..z)
		newLocations[hashLoc(x,y,z)] = {x=x,y=y,z=z}
	end
end

function findNearestPoint()
	local h,x,y,z = t.getLoc()

	local selV = nil
	local selK = nil
	local minSize = -1

	for key,value in pairs(newLocations) do
		if value ~= nil then

			vt.reset()
			vt.setLoc(h,x,y,z)

			vt.goto(value.x,value.y,value.z)
			moves = vt.getMoves()
			
			if minSize == -1 then
				minSize = moves
				selV = value
				selK = key
			elseif minSize > moves then
				minSize = moves
				selV = value
				selK = key
			end

			if moves == 1 then
				break
			end
		end
	end

	return selK
end

function getScanList()
	local list = {false, false, false, false}

	vt.reset()
	vt.setLoc(t.getLoc())

	for i=1,4 do
		local h = vt.getLoc()
		list[h+1] = not isHandled(vt.getLocFd())
		vt.rt()
	end

	return list
end

function scan()
	if t.detectUp() then
		addQueueRoof(t.getLocUp())
	else
		setScannedRoof(t.getLocUp())
	end
	
	local list = getScanList()
	
	local h = t.getLoc()

	for i=1,4 do
		local nh = ((i-1) + h) % 4
		if list[nh + 1] then
			t.setHeading(nh)
			if t.detect() then
				addQueue(t.getLocFd())
			else
				setScanned(t.getLocFd())
			end
		end
	end
end

function isEmpty()
	return  next(newLocations) == nil
end


t.setLoc(0,0,0,0)

scan()

print(newLocations)

while not isEmpty() do
	local key = findNearestPoint()

	if key == nil then
		print("oops!")
		error()
	end

	local value = newLocations[key]

	newLocations[key] = nil

	t.goto(value.x,value.y,value.z)

	setScanned(value.x,value.y,value.z)

	if t.detect() then
		addQueue(t.getLocFd())
	else
		setScanned(t.getLocFd())
	end

	scan()

	if isEmpty() then
		newLocations = roofLocations
		scannedLocations = roofScanned
		roofLocations = {}
		roofScanned = {}
	end

end

t.goto(0,0,0)
