local FUEL = 1
local PLUG = 2
local CHEST = 3
local JUNKSTART = 4
local JUNKEND = 6

function isValuable()
	-- check junk
	for i=JUNKSTART,JUNKEND do
		t.select(i)
		if not t.detect() or t.compare(i) then
			return false
		end
	end

	return true
end

function isChest()
	if t.compare(CHEST) then
		return true
	end
	return false
end

function isChestDown()
	if t.compareDown(CHEST) then
		return true
	end
	return false
end

function isChestUp()
	if t.compareUp(CHEST) then
		return true
	end
	return false
end

function digDown()
	if isChestDown() then
		t.select(1)
		t.digChestDown()
	else
		t.select(1)
		t.digDown()
	end
end

function digUp()
	if isChestUp() then
		t.select(1)
		t.digChestUp()
	else
		t.select(1)
		t.digUp()
	end
end

function checkWalls()
	for i=1,3 do
		if isValuable() then
			if isChest() then
				t.digChest()
			end
			t.select(1)
			t.dig()
		end
		t.turnRight()
	end
	if isValuable() then
		if isChest() then
			t.digChest()
		end
		t.select(1)
		t.dig()
	end
end

function drillDown(dp)
	if t.detectDown() then
		digDown()
	end
	while not t.detectDown() do
		checkWalls()
		t.downAttack()
		if t.detectDown() then
			digDown()
		end
		dp = dp + 1
	end
	return dp
end

function drillUp(dp)
	while dp > 1 do
		checkWalls()
		while t.detectUp() do
			digUp()
			os.sleep(0.5)
		end
		t.upAttack()
		dp = dp - 1
	end

	return dp
end


function mine()
	local depth = 0
	local heading = t.getLoc()

	-- go down, place cap
	digDown()
	for i=1,2 do
		t.downAttack()
		t.select(1)
		digDown()
		depth = depth + 1
	end

	t.select(PLUG)
	t.placeUp()

	-- drill to bedrock hole 1
	depth = drillDown(depth)

	-- go up 10
	t.select(1)
	for i=1,6 do
		t.upDigAttack()
		depth = depth - 1
	end

	t.turnHeading(heading)

	-- go to next position
	t.forwardDigAttack()
	t.forwardDigAttack()
	t.turnLeft()
	t.forwardDigAttack()
	t.turnRight()

	t.digDown()
	while not t.detectDown() do
		while not t.dn() do
			t.attackDown()
		end

		t.digDown()
		depth = depth + 1
	end

	-- dig up -- hole 2
	depth = drillUp(depth)

	-- place cap
	t.upDigAttack()
	t.select(PLUG)
	t.placeDown()

	t.turnHeading(heading)

	-- clear path for player
	t.digAllUp()
	t.placeDown(2)
	t.turnRight()
	t.forwardDigAttack()
	t.digAllUp()
	t.placeDown(2)
	t.turnRight()
	t.forwardDigAttack()
	t.digAllUp()
	t.placeDown(2)
	t.forwardDigAttack()
	t.digAllUp()
	t.placeDown(2)
	t.turnRight()

	t.forwardDigAttack()
	t.digAllUp()
	t.placeDown(2)
	t.turnRight()
	t.forwardDigAttack()
	t.digAllUp()
	t.placeDown(2)
	t.forwardDigAttack()
	t.digAllUp()
	t.placeDown(2)
end

function next()
	-- go to next place
	t.select(2)
	t.digAllUp()
	t.placeDown(2)
	t.lt()
	t.forwardDigAttack()

	t.digAllUp()
	t.placeDown(2)
	t.rt()
	t.forwardDigAttack()

	t.digAllUp()
	t.placeDown(2)
	t.rt()
	t.forwardDigAttack()

	t.digAllUp()
	t.placeDown(2)
	t.lt()
	t.forwardDigAttack()

	t.digAllUp()
	t.placeDown(2)
	t.lt()
	t.forwardDigAttack()

	t.digAllUp()
	t.placeDown(2)
	t.rt()
end

function dumpChest()
	local map = {
		32,13, 64, 1,
		 1, 1,  0, 0,
		 0, 0,  0, 0,
		 0, 0,  0, 0
	}

	t.rt()
	t.rt()

	t.place(3)
	for i=1,16 do
		if turtle.getItemCount(i) > map[i] then
			t.select(i)
			turtle.drop(turtle.getItemCount(i) - map[i])
		end
	end

	t.rt()
	t.rt()
end

function set(moves, sideMoves, sideLength, sideCount)
	local f,err = fs.open("/core.conf", "w")
	f.write(textutils.serialize({
		moves=moves,
		sideMoves=sideMoves,
		sideLength=sideLength,
		sideCount=sideCount}))
	f.flush()
	f.close()
end

function get()
	if not fs.exists("/core.conf") then
		return nil
	end

	local f, err = fs.open("/core.conf", "r")

	local data = f.readLine()

	f.close()

	return textutils.unserialize(data)
end

function continue()
	local data = get()
	local moves = data.moves
	local sideMoves = data.sideMoves
	local sideLength = data.sideLength
	local sideCount = data.sideCount

	if moves % 2 == 0 then
		mine()
	else
		next()
	end

	sideMoves = sideMoves + 1

	if sideMoves >= sideLength then
		t.lt()
		sideCount = sideCount + 1
		sideMoves = 0
	end

	if moves % 2 == 0 then
		dumpChest()
	end

	moves = moves + 1

	if sideCount >= 2 then
		sideLength = sideLength + 1
		sideCount = 0
	end

	set(moves,sideMoves,sideLength,sideCount)
end


-- start program --

local args = { ... }

local command = args[1]

if command == "mine" then
	mine()
elseif command == "next" then
	next()
elseif command == "start" then
	set(0,0,1,0)
	continue()
elseif command == "continue" then
	local c = 1
	if args[2] ~= nil then
		c = tonumber(args[2])
	end

	for i=1,c do
		continue()
	end
end


